## Memory Leak Detection in C++ - 在 C++ 中检测内存泄漏的工具 [**Back**](./../translation.md)

> * 原文链接 : [Memory Leak Detection in C++](http://www.linuxjournal.com/article/6556?page=0,0)
* 原文作者 : [Cal Erickson](http://www.linuxjournal.com/user/801087)
* 译者 : [aleen42](https://github.com/aleen42) 
* 校对者: 暂无
* 状态 :  翻译中
* <img src="./cover110.small.jpg"> 来源问题：2013年7月第110号问题



&#160; &#160; &#160; &#160;谨记，千万不要延期修复内存泄漏的问题。而且，你可以使用一个或者多个的便捷检测工具，去作为你开发过程的一部分。

&#160; &#160; &#160; &#160;在早期，有那么一篇叫《在嵌入式系统中检测内存泄漏问题》，由LJ于2002年9月编写，并可在 [www.linuxjournal.com/article/6059](www.linuxjournal.com/article/6059) 查看的文章。该篇文章谈及到当我们使用 C 作为编程语言时，如何去检测内存泄漏的问题。而接下来，这篇文章将探讨如果是在 C++ 中，我们又如何检测呢？该文所谈及的检测工具，它们只能检测到应用程序的错误代码，但不能检测内核态下的内存泄漏情况。所有的这些工具，它们都被使用在 MontaVista Linux 专业版2.1和3.0产品上。其中的 dmalloc 更是被嵌入 MontaVista Linux 中。

&#160; &#160; &#160; &#160;当在嵌入式系统中开发应用程序时，设计师和工程师一定要对系统的内存资源，其使用情况要特别小心。不同于工作站（workstation）的是，嵌入式系统的内存资源非常有限。一般，只有理想的程序才不会占用任何的内存交换区（swap area）。当一个系统耗尽其资源时，它只能惊慌地扼杀掉部分的程序以腾出空间，给出所需要的资源。因此，在写程序时，防止内存泄漏是至关重要的。现在，有许多的工具能帮助程序员找到资源泄漏的地方。而所有这里讨论的这些程序，它们发行时都会携带有自己的测试程序。

&#160; &#160; &#160; &#160;在这些测试程序中，有一种方法是我亲眼目睹到应用开发者能成功使用的。其中包括使用一个工作站去开发原型代码以及尽可能地找出其中的漏洞。而在这种方法中，我强烈地建议去使用内存泄漏检测工具。因为只有这样，应用开发者在工作站检查漏洞时，才会更有信心地认为，转变到目标处理器将会更加简单。使用工作站的一个主要原因在于它们不仅便宜，而且参与的开发者都会人手一台。而目标，换句话说，是一件稀少而又有着急切需求的一样东西。

&#160; &#160; &#160; &#160;大部分的內存泄漏检测程序，都能提供出整套的源代码。一般，我们都会把其配置在基于 x86 的平台上。而如果需要其运行在非 x86 上，那么则需要进行移植。移植的工作可能就是重新编译，链接并执行，又可能是需要一些从一个平台到另一个平台的汇编代码。其中部分的工具，都会有关于使用交叉编译环境的窍门以及建议。

dmalloc

&#160; &#160; &#160; &#160;这是一款我曾经在2002年9月攥写的文章中提到的工具。该工具的作者表明其在 C++ 领域的知识是有限的，以至于对内存泄漏的检测也是有限的。为了在 C++ 及线程中使用 dmalloc，那么我们必须把该应用链接成静态。

ccmalloc

&#160; &#160; &#160; &#160;ccmalloc 工具是有着一个简单使用模块的内存分析工具。该模块支持动态链接库，但不支持 dlopen 的使用。ccmalloc 不仅能检测内存泄漏的情况，它还能对同一个数据进行释放，并签名、重写和写回到已被释放的数据区域。除此之外，它还能展示分配与释放的统计数据。该工具适用于优化并去除多余代码，而且这在 C++ 内是支持使用的。它还在整个调用链上，提供了文件与行号信息，而不仅仅是调用 malloc/free。该功能也支持在 C++ 上的使用。使用 ccmalloc 并不需要重新编译；而只需要简单地为 **lccmalloc -ldl** 或 **ccmalloc.o -ldl** 建立连接。ccmalloc 提供了调用链的基本展示、自定义展示以及可选择性展示。而且还能展示一个经过压缩的日志文件和一个叫 `.ccmalloc` 的配置文件。ccmalloc 的主要文档是放在一个命名为 `ccmalloc.cfg` 的文件里，而它那些包含有程序的测试文件则提供了更多的文档信息。这是因为 nm 和 gdb 都需要获取更多关于标志位和 gzip 的信息来压缩日志文件。

NJAMD

&#160; &#160; &#160; &#160;NJAMD 的作者声称：“NJAMD 不仅仅是另一个的 malloc 漏洞检测软件”。与大部分内存定位漏洞检测软件相比，NJAMD 中使用了新的函数去替代标准的定位函数。该函数能伴随着内存的使用，展现出不同的检测功能。尤其是能检测到动态缓存的上溢/下溢，以及内存释放后的重用情况。我们可以使用 LD_PRELOAD 去加载用于构建 NJAMD 的库，也可以直接把这些库链接到程序当中。在第一次内存寻址时，NJAMD 会申请一块大的内存缓存空间（大约20MB），并分割成小块，供程序使用。这是因为，NJAMD 的程序需要内存空间。

&#160; &#160; &#160; &#160;NJAMD 可以单独通过一个前端使用或者在 gdb 中使用。它可以允许我们对程序完成后的堆进行分析，也允许只要简单地预加载对应的库，程序就不需要重新编译即可查漏洞的功能。此外，它还可以追踪库中那些包装有 malloc 和 free、GUI 组件寻址以及 C++ 中 new 和 delete 的库函数，它们的内存泄漏情况。通常，一个内存泄漏问题虽潜伏在那等待着时机去击打我们，但不会立刻被发现。因此，追踪到它们会消耗大量的时间。NJAMD 有着许多环境变量，用于设置不同的检测登记。与其他软件相比，NJAMD 在性能上会是一个很大的问题。因此，该工具只能在开发期间使用。倘若把其置于生产环境，那么将会导致系统严重迟缓。

YAMD

&#160; &#160; &#160; &#160;YAMD （也是另一个内存漏洞检测工具）是另一个用于计算内存寻址块边界的软件包。它是通过使用处理器的分页机制来做到这点的。通过这种功能，YAMD 能检测到程序越界读写的情况

<a href="http://aleen42.github.io/" target="_blank" ><img src="./../../pic/tail.gif"></a>
