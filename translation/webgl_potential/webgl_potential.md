## The WebGL potential - WebGL的潜在性 [**Back**](./../translation.md)

> * 原文链接 : [The WebGL potential](http://typedarray.org/the-webgl-potential/)
* 原文作者 : [typedarray.org](http://typedarray.org/)
* 译者 : [aleen42](https://github.com/aleen42) 
* 校对者 : 暂无
* 状态 : 翻译中

### WebGL的潜在性

&#160; &#160; &#160; &#160;由于 WebGL 支持性将更加广泛的谣言，特别是 IE 浏览器，因此，关于真正跨平台的一组 GPU API 的承诺基本上已经出现。我个人认为，这承诺如果实现，那么将会对在 web 上许多的东西产生影响，特别是关于人们怎么开发交互性的内容。但是，我也希望这能推进 web 前进。

#### WebGL 也可用于二维图像处理

<img src="./grotto-uv.png"> 

&#160; &#160; &#160; &#160;[WebGL](http://www.khronos.org/webgl/) 基本上是一个对 OpenGL ES 2.0 功能集所开放的低级 JavaScript 接口（在幕后是使用了 OpenGL/ES 2.0 或 DirectX）。大家都误以为 WebGL 是仅仅用于三维图像处理，而事实上并非所然。通过利用低级的基元，我们不仅能像 [three.js](https://github.com/mrdoob/three.js/) 那样为三维图像处理重建出高级的结构，还能简化二维图像处理的基元，用于支持二维图像处理。我们都知道，两个三角形能够形成一个方形，且该方形能承接一个纹理。这就是为什么二维图形 GPU 加速能出现我们的眼前。大部分像 [Cocos2D-x](http://www.cocos2d-x.org/) 或 [Pixi.js](https://github.com/GoodBoyDigital/pixi.js) 等框架都是通过回退到 Canvas 去实现加速，这是因为 WebGL 无法做到的。你需要滤波、颗粒度效果吗？通过使用像 WebGL 提供的一个可编程管道（着色程序），我们也能实现图像的可再生化。

&#160; &#160; &#160; &#160;在我们[为 Flash 开发 Stage3D 库时](http://www.youtube.com/watch?v=c0IwvN4IdH4)，我们就想着尽可能地揭露低级的基元，以使得人们可以在这基础上开发他们所需要的框架。特别是对于游戏开发者来说，他们迫切需要通过颗粒度等级来控制所有的一切事物，并获得超乎想象的高性能。另一方面，我们了解到大部分开发者会热衷于使用他们熟悉的高级别 API 分离基元，而不是低级别的 GPU 基元。因此，我们创造出了 [Starling](http://gamua.com/starling)。它可以基于 Stage3D 之上，快速成为二维图像内容的框架。Rivio 通过使用该框架，把 [Angry Birds](https://apps.facebook.com/angrybirds/?fb_source=timeline) 装载于 Facebook 中。此外，Zynga 最近也通过该框架装载了 [Ruby Blast](https://apps.facebook.com/rubyblast/?fb_source=search&ref=ts&fref=ts)。

&#160; &#160; &#160; &#160;除了帮助游戏开发之外， WebGL还能推动了交互的体验以及部分的数字化营销页面，像为人熟知多年的 [thefwa.com](http://www.thefwa.com/) 和传统通过 Flash 实现交互的交付物。不仅如此，它还彻底变更了开发者构件移动端应用的方式。所有你在手机上所能欣赏到的平缓 UI 组件，全都是通过 GPU 加速的，且由 OpenGL ES 2.0（iOS、Android）或 DirectX（Windows 8）所提供服务支持。当然，我希望能有越来越多的 UI 框架出现，以提供基于 WebGL 上通过 GPU 快速加速的 UI 组件。[Feathers](http://feathersui.com/) 就是一个很好的例子。

&#160; &#160; &#160; &#160;这意味着我们都通过 WebGL 去完成所有的事情？并不是，这取决于实际的情况。对于多文本内容来说，使用一个由 CSS 定义样式的传统 DOM，会更加的有效，像一个新闻页面、一个论坛或简单的表单应用。CPU 是善于处理像字体编译或矩阵计算等其他事情。因此，如果我们能结合好两者（基于 CPU 或 GPU 的编译器），这将会是一个很强大的混合。

#### 隐式 vs 显式

&#160; &#160; &#160; &#160;如今，为了在浏览器中获得更高的性能，各种技术都被构建成一种欺诈系统的技术。在 Stackoverflow 上看到关于性能欺诈的谈话时，我不禁感到有点恐怖。因为，你会因为你的臆想，或更坏情况下所产生的副作用，使得你的项目终结。在过去的几年，关于对 DOM 使用 GPU 加速的一些神奇方案，过去几年人们都有很多的言论。可是，想要产生有效的加速是非常的难。为什么？因为一个显示列表允许了许多东西的呈现，而这些东西在 GPU 上是很难实现有效加速的。复杂的嵌套、蒙层、混合以及能通过 JavaScript 或 CSS 可控的，都很难实现加速。随着开发者尝试在浏览器上，去写这些所谓神奇的代码来加速 DOM 元素。使用到这些代码的你，或许会对此产生臆想或异常，因为这不可能覆盖到成千上万可能会遇到的用例。而这点也使得如今开发者很难在它们的表面上开发内容。那些你无法控制的东西在幕后悄然发生，这将使得你的开发终止于所谓的伏都优化和鸡骨头似的建议像：

*使用这些属性，你需要确保美欧嵌套任何东西，而且确保 alpha 值已设置成零，并保证不要从 DOM 结构中移除该元素。*

&#160; &#160; &#160; &#160;其实，你所需要的是揭露出来的低级别基元（像 WebGL），并使得人们可以开发更高级别的框架。这也是最灵活的一种模型。倘若你是有性能上的问题或者漏洞，那么你可以去修复它。而如果你不喜欢一个框架的结构，拿就替换它。因为所有的代码都是基于内容的，而不是基于浏览器。这就是项目 [DOM.js](https://github.com/andreasgal/dom.js/) 背后的思想。

&#160; &#160; &#160; &#160;最近有那么一个案例，那就是通过使用 [translateZ](http://msdn.microsoft.com/en-us/library/ie/jj200289(v=vs.85).aspx)（CSS3）去强制 GPU 进行加速。在这里，我再重新强调一次的是，该方法属于一个非法侵入的方法，且具有副作用。该方法原本是开发用于三维图像效果，但开发者如今只用在二维效果上，而没真正了解到在幕后所发生的隐式事件。其实在背后，你想要加速的 DOM 元素会进行点阵化（一般如果该元素拥有很多的内嵌子元素，那么，这简单的第一步将会是很耗时），然后，位图会在幕后被上传至 GPU （要记住你是无法调用任何的上传 API）。此后，才重新混合于页面中。顺便说一下的是，如果纹理是非常得大，那么它将会挫击在内存外运行的其他设备，并使得开发者坠入黑暗。

&#160; &#160; &#160; &#160;再次强调，有着低级别基元，你可以允许高级开发者开发高级别的框架（在这里指的是用 JavaScript），然后给其他开发者一个使用 API 的机会去了解这些基元在背后的显式事件，而这过程仅带有最少量的副作用。尝试使用这些高级框架去解决事情的人，他们有一个机会能看到背后的实现，并了解哪里存在有问题，且背后到底是如何工作的。作为一个 Flash 开发者，他们开发相似技术，如去使得代码运行更快这事情已经并非新鲜的事情。

<a href="http://aleen42.github.io/" target="_blank" ><img src="./../../pic/tail.gif"></a>
