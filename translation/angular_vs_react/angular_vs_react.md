## Angular vs. React - the tie breaker - Angulr 对比 React - 决胜局 [**Back**](./../translation.md)

> * 原文链接 : [Angular vs. React - the tie breaker](https://www.airpair.com/angularjs/posts/angular-vs-react-the-tie-breaker)
* 原文作者 : [Amit Kaufman](https://github.com/amitkaufman)
* 译者 : [aleen42](https://github.com/aleen42) 
* 校对者 : 暂无
* 状态 : 翻译中

![](./EgrRejl.png)

## 1. 简介

&nbsp; &nbsp; &nbsp; &nbsp;在不久前，我们开发团队需要为 Wix 公司的其中一个旗舰产品 —— html wysiwyg 网页编辑器，选定一种开发框架技术。该产品是一个大型的单页面应用。由于里面含有复杂的逻辑、大量与其他内敛框架（iframe）和服务器之间的通信，以及许多的用户体验性操作，团队的开发人数多达40人。此前，我们对 ReactJS 和 AngularJS 都有一定的开发经验。但是，框架的选定却在两者间徘徊不定。这是因为，一方面，AngularJS 的声明式编程思想使得框架变得易于使用。另一方面，ReactJS 带给了我们开发的简易性。一系列的概念证明促使我们形成了这次的决胜局。下面，该文将带大家探讨一下两者之间的对决。

### 1.1 打包

&nbsp; &nbsp; &nbsp; &nbsp;打包（packaging）指的是一种能使得代码以预期方式运行并部署的方法。为了达到快速的加载，我们希望在前期只加载最低条件下所需要的代码，并在后期根据所需逐步加载。如果能这样的话，我们就不需要在开发新功能时，考虑是否会降低加载速度的问题。

&nbsp; &nbsp; &nbsp; &nbsp;对于这方面需求，AngularJS 只提供了少量限制的方法去实现（大部分是 html 模板），而且当我们尝试去实现的时候，我们发现我们其实只是在组装代码而已。

&nbsp; &nbsp; &nbsp; &nbsp;简而言之，Angular 框架太过于固执与死板。相反, React 并没有理会太多。它可以直接结合 plain JS使用，而我们只需要使用 requirejs，就能实现对部分代码的延迟加载。此外，React 还可以与其他像 webpack 的打包工具共同使用。

*胜者：React*

### 1.2 学习曲线

&nbsp; &nbsp; &nbsp; &nbsp;我相信每个人都知道，精通 Angular 之路颠簸且漫长：入门虽快，经久衰败，犹如婚姻……

&nbsp; &nbsp; &nbsp; &nbsp;至于 React，我们发现只需要花费大概一周的时间去学习，就能到达一个较高的层次。只需些许时间，我们就能习惯于该种单向的工作流程。尤其是对于 web 开发者来说，一旦你能花那么点时间去学习 React 的话，那么整个框架都会变得清晰易懂。

&nbsp; &nbsp; &nbsp; &nbsp;Angular 的生命周期是非常复杂的，倘若不去细致查看框架的代码，是无法达到精通的境界。在该框架的编译和链接期间，它并不能给到你一个直观的界面去查看详细的过程。正因为这样，在某种的情况下，如若遇到异常，你会感到无比疑惑（该异常有可能是来自编译时的大量递归或指令间的冲突）。相对的，React 只含有少量的生命周期方法，而且这些方法的定义都是不言而喻。所以，使用 React 其中一个最大的特征就是你并不需要去阅读它自身的代码。

*胜者：React*

### 1.3 代码抽象

&nbsp; &nbsp; &nbsp; &nbsp;好的代码抽象是无比重要的，因为代码抽象能为我们开发者抽象出便捷的开发接口并隐藏开发中不必要的细节。

&nbsp; &nbsp; &nbsp; &nbsp;我们发现，Angular 的抽象部分存在有一定的漏洞。这意味着只有在清楚地了解底层的模型后，我们才能真正地运用 Angular 所提供的抽象方法。这就是为何大量的开发者，在调试自身代码的过程中需要调试 Angular 框架内部的代码。

&nbsp; &nbsp; &nbsp; &nbsp;为了应对这些漏洞，Angular 为我们提供了类似指令优先级（directive priority）的概念。但是，我不禁要问道，“在使用第三方供应商所提供的指令时，我们该怎么去控制这些指令的优先级呢？况且，为什么我还要去考虑这些所谓的优先级呢？为什么同样在一个 html 节点上，不同的指令有时候会不起效用？为什么我们还要去理解汇编的周期呢？”

&nbsp; &nbsp; &nbsp; &nbsp;至于React 的抽象部分，在某些情况下限制了开发的灵活性。例如，我们不能往 html 标签或一个用于组合的标签上添加属性。针对这样的问题，React 所实现的混合类型提供了解决办法（该混合类型仅允许在生命周期方法上进行部分重叠，并拥有一个可预测的执行顺序）。而该解决办法并不会造成任何的代码漏洞（如前节所述，更重要的是我们并不需要再去查看 React 的内部代码）

胜者：React

### 1.4 模型复杂度

&nbsp; &nbsp; &nbsp; &nbsp;关于模型复杂度的问题，我意指我们该如何去设计后面 view 层需要所描绘的数据模型。

&nbsp; &nbsp; &nbsp; &nbsp;由于需要拷贝多份数据进行比较（copy-n-compare），Angular 在处理代码域时，其性能表现是极其敏感的。这就意味着，我们若使用 Angular，我们就不能设计有大型的数据模型。当然，凡事有两面。优点在于这样能使得代码变得简单易懂，且可测试性高；但缺点是你需要拆解平时习惯使用的物品，并重新构建（例如，拆解服务性请求）。

&nbsp; &nbsp; &nbsp; &nbsp;React 则在这方面给予了你非常大的自由度。因为，你并不需要去考虑性能的问题。当然，结果仍取决于你的代码质量好坏。

胜者：平手

### 1.5 调试

&nbsp; &nbsp; &nbsp; &nbsp;开发过程中，当有代码不起效用时，我们都会开启令人厌烦的调试工作。一般，我们团队都会把该步骤分成两种主要的方案：指出为何逻辑部分失效和理解是什么导致 HTML 输出的该结果。

&nbsp; &nbsp; &nbsp; &nbsp;Angular 是一个事件型驱动系统。该类系统易于编写，但难于调试。这是因为该类系统的异常追踪栈（stack-traces），其里面的信息往往会比想象中要多且不同。尽管如此，Angular 还是提供了一种像服务层的逻辑结构。只要我们妥当使用，该结构就能使得代码易于测试和调试。当然，任何好的程序员都希望把代码和逻辑结构抽离分开，或者不依赖于任何的逻辑结构去调试代码。

&nbsp; &nbsp; &nbsp; &nbsp;当部分 Angular 指令无效时，其中一种办法就是去重新用不同的方式去编写该部分代码。这是因为，太多的逻辑依赖于该部分代码。而另一种办法就是去调试 Angular 本身的代码 —— 这是一个没有价值的工作。

&nbsp; &nbsp; &nbsp; &nbsp;React 框架自身只有两种主要的应用场景：更新数据模型/通过用户事件执行其他行为，以及经常相同的单向工作流程。这就意味着，我们开发者只需要调试少许的地方就能找到代码的漏洞